import { EmbedBuilder } from "discord.js";
import { getTopKeywords } from "./preprocess";
import { groupTopics } from "./groupTopics";
import { buildTimeline } from "./buildTimeline";
import { getTopLinks } from "./getTopLinks";

type Msg = {
  time: number;
  author: string;
  text: string;
  links: string[];
  attachments: string[];
  reactions: string[];
};

// emoji set i liked
const E = {
  sheep: "🐑",
  clock: "⏰",
  topics: "🌾",
  activity: "🐾",
  link: "🔗",
  file: "📎",
  spark: "✨",
  faces: "👥",
  react: "💟",
  chart: "📊",
  pin: "📌"
} as const;

export function buildEmbedFromAnalysis(
  messages: Msg[],
  context: { channelName: string; hours: number }
) {
  const texts = messages.map(m => m.text).filter(Boolean);

  // base analysis
  const keywords = getTopKeywords(texts, 8);
  const topicGroups = groupTopics(messages, 3);
  const timeLine = buildTimeline(messages);
  const media = getTopLinks(messages);

  // stats
  const uniqueUsers = new Set(messages.map(m => m.author)).size;
  const perUser = countPerUser(messages);
  const topUsers = perUser.slice(0, 3).map(([u, n]) => `@${u} (${n})`);
  const reactionTotals = countReactions(messages);
  const topReactions = reactionTotals.slice(0, 3).map(([e, n]) => `${e} × ${n}`);

  const imageCount = countByExt(messages.flatMap(m => m.attachments), [
    "png",
    "jpg",
    "jpeg",
    "gif",
    "webp"
  ]);
  const linkCount = media.links.length;
  const fileCount = media.files.length;

  // find most reacted message
  const mostReacted = findMostReacted(messages);

  const embed = new EmbedBuilder()
    .setTitle(`${E.sheep} recap — #${context.channelName} (last ${context.hours}h)`)
    .setColor(0x79c2ff)
    .setDescription(
      [
        `${E.spark} summary`,
        `• messages: ${messages.length}`,
        `• people: ${uniqueUsers}`,
        `• reactions: ${sum(reactionTotals.map(([, n]) => n))}`,
        `• top: ${keywords.slice(0, 5).map(x => x.term).join(", ") || "—"}`
      ].join("\n")
    )
    .addFields(
      {
        name: `${E.clock} timeline`,
        value: formatTimeline(timeLine),
        inline: false
      },
      {
        name: `${E.topics} topics`,
        value: formatTopicGroups(topicGroups),
        inline: false
      },
      {
        name: `${E.activity} activity`,
        value: [
          `• most active: ${topUsers.join(", ") || "—"}`,
          `• images: ${imageCount}  • links: ${linkCount}  • files: ${fileCount}`,
          `• top reacts: ${topReactions.join("  ·  ") || "—"}`
        ].join("\n").slice(0, 900),
        inline: false
      },
      {
        name: `${E.pin} most reacted message`,
        value: mostReacted
          ? `**${mostReacted.author}** (${mostReacted.totalReacts} reacts):\n> ${mostReacted.text || "—"}`
          : "—",
        inline: false
      },
      {
        name: `${E.link} links & files`,
        value: formatLinks(media),
        inline: false
      }
    )
    .setTimestamp(new Date())
    .setFooter({ text: `Generated by RecapBot` });

  // image preview (attachments first, then links)
  const isImageUrl = (u: string) =>
    /(\.(png|jpe?g|gif|webp)(\?.*)?$)|\/attachments\//i.test(u);

  const preview =
    messages.flatMap(m => m.attachments).reverse().find(isImageUrl) ||
    media.files.find(isImageUrl) ||
    media.links.find(isImageUrl) ||
    null;

  if (preview) embed.setImage(preview);

  return embed;
}

/* helpers */

function countPerUser(messages: { author: string }[]) {
  const map = new Map<string, number>();
  for (const m of messages) map.set(m.author, 1 + (map.get(m.author) ?? 0));
  return Array.from(map.entries()).sort((a, b) => b[1] - a[1]);
}

function countReactions(messages: { reactions: string[] }[]) {
  const map = new Map<string, number>();
  for (const m of messages) for (const r of m.reactions) map.set(r, 1 + (map.get(r) ?? 0));
  return Array.from(map.entries()).sort((a, b) => b[1] - a[1]);
}

function sum(nums: number[]) {
  return nums.reduce((a, b) => a + b, 0);
}

function countByExt(urls: string[], exts: string[]) {
  const rx = new RegExp(`\\.(${exts.join("|")})(\\?.*)?$`, "i");
  return urls.filter(u => rx.test(u)).length;
}

function findMostReacted(messages: Msg[]) {
  let top: Msg | null = null;
  let max = 0;
  for (const m of messages) {
    const total = m.reactions.length;
    if (total > max) {
      max = total;
      top = m;
    }
  }
  return top ? { author: mAuthor(top), text: shorten(top.text), totalReacts: max } : null;
}

function mAuthor(m: Msg) {
  return m.author || "unknown";
}

function shorten(text: string, max = 100) {
  return text.length > max ? text.slice(0, max) + "..." : text;
}

function formatTimeline(items: { timeText: string; who: string; preview: string }[]) {
  if (!items.length) return "—";
  return items.map(i => `• ${i.timeText} — **${i.who}**: ${i.preview}`).join("\n").slice(0, 900);
}

function formatTopicGroups(groups: { keyword: string; samples: string[] }[]) {
  if (!groups.length) return "—";
  return groups.map(g => `• **${g.keyword}** — e.g. “${g.samples[0] ?? "…"}”`).join("\n").slice(0, 900);
}

function formatLinks(m: { links: string[]; files: string[] }) {
  const L = m.links.map(u => `${E.link} ${u}`).join("\n");
  const F = m.files.map(u => `${E.file} ${u}`).join("\n");
  return (L || F) ? [L, F].filter(Boolean).join("\n") : "—";
}